---
title: '种花问题'
date: 2019-10-02
categories: LeetCode刷题 # 分类只能有1个
tags: # 标签可以有多个
  - 算法
  - LeetCode
---

:::tip
假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给定一个花坛（表示为一个数组包含 0 和 1，其中 0 表示没种植花，1 表示种植了花），和一个数  n 。能否在不打破种植规则的情况下种入  n  朵花？能则返回 True，不能则返回 False。
:::

<!-- more -->

- 类型：数组类

- 难度: 简单

## 题目描述

假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给定一个花坛（表示为一个数组包含 0 和 1，其中 0 表示没种植花，1 表示种植了花），和一个数  n 。能否在不打破种植规则的情况下种入  n  朵花？能则返回 True，不能则返回 False。

## 示例

**示例一:**

输入: flowerbed = [1,0,0,0,1], n = 1

输出: True

**示例二:**

输入: flowerbed = [1,0,0,0,1], n = 2

输出: False

## 思路

1.  给数组两端各加 0 为边界
1.  使用 reduce 遍历数组，并判断当前是否为 0，两侧是否为 0，如果满足，累加器加 1，并修改当前值为 1
1.  注意遍历的时候要避开第一位和最后一位，它们只是辅助元素

## 代码

```javascript
/**
 * @param {number[]} flowerbed
 * @param {number} n
 * @return {boolean}
 */
var canPlaceFlowers = function(flowerbed, n) {
  flowerbed = [0, ...flowerbed, 0]
  return (
    flowerbed.reduce((pre, curValue, index) => {
      if (index === 0 || index === flowerbed.length - 1) return pre
      if (curValue === 0 && flowerbed[index - 1] === 0 && flowerbed[index + 1] === 0) {
        pre++
        flowerbed[index] = 1
      }
      return pre
    }, 0) >= n
  )
}
```

## 结果

![](http://lailailee.oss-cn-chengdu.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/leetcode-605.png)

## 复杂度分析

- 时间复杂度：O(n)，

只需要遍历一遍 flowerbed 数组，所以时间复杂度是 O(n)

- 空间复杂度：O(1)。
