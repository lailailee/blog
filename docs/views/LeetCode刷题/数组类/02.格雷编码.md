---
title: '格雷编码'
date: 2019-10-04
categories: LeetCode刷题
tags: # 标签可以有多个
  - 算法
  - LeetCode
---

:::tip
格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。

给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。
:::

<!-- more -->

- 类型：数组类

- 难度: 中等

## 题目描述

格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。

给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。

## 示例

**示例一:**

输入: 2

输出: [0,1,3,2]

解释:

00 - 0

01 - 1

11 - 3

10 - 2

对于给定的  n，其格雷编码序列并不唯一。

例如，[0,2,3,1]  也是一个有效的格雷编码序列。

00 - 0

10 - 2

11 - 3

01 - 1

**示例二:**

输入: 0

输出: [0]

解释: 我们定义格雷编码序列必须以 0 开头。

给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。

因此，当 n = 0 时，其格雷编码序列为 [0]。

## 思路

![image](http://lailailee.oss-cn-chengdu.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/leetcode-58.jpg)

观察得出 n 的结果是 n-1 的结果先是正序前面加了个 0，后是倒序前面加了个 1，针对这个规律，所做解法步骤如下：

1. 创建 getCode 函数，传入 n 返回相应位数的二进制格雷编码数组
2. 创建 getCombin 函数，传入一个二进制格雷编码数组，将其与[0,1]以我观察到的规律进行合并并返回
3. 边界条件，当 n=0 时，返回[0]，当 n=1 时，返回[0,1]
4. 当 n>1 时，返回 getCombin(getCode(n - 1))的值，即为[0,1]与 n-1 时的二进制格雷编码的合并，层层递归直到是 n=1 时的返回[0,1]后，逐渐向后回溯
5. 将二进制格雷编码数组转化为十进制格雷编码数组

## 代码

```javascript
/**
 * @param {number} n
 * @return {number[]}
 */
var grayCode = function(n) {
  let getCombin = a => {
    let c = []
    a.forEach(item => {
      c.push('0' + item)
    })
    a.reverse().forEach(item => {
      c.push('1' + item)
    })
    return c
  }
  // 使用递归合并返回值
  let getCode = n => {
    //题中的边界条件
    if (n === 0) {
      return [0]
    } else if (n === 1) {
      return [0, 1]
    } else {
      return getCombin(getCode(n - 1))
      // 3
      // getCombin(getCode(2))
      // getCombin(getCombin(getCode(1))))
      // getCombin(getCombin([0,1]))
    }
  }
  //最后把每一项转化为二进制
  return getCode(n).map(item => parseInt(item, 2))
}
```

## 结果

Accepted

- 12/12 cases passed (60 ms)
- Your runtime beats 98.62 % of javascript submissions
- Your memory usage beats 27.78 % of javascript submissions (34.1 MB)

## 复杂度分析

- 时间复杂度：O(n)，

递归 n 层，所以时间复杂度是 O(n)

- 空间复杂度：O(n)。
